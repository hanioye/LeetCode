# 简述

> 康托展开是一个全排列到一个自然数的双射，常用于构建hash表时的空间压缩。设有n个数（1，2，3，4,…,n），可以有组成n!种的排列组合，康托展开表示的就是是当前排列组合在n个不同元素的全排列中的名次。



# 康托展开原理

**`X=a[n]\*(n-1)!+a[n-1]\*(n-2)!+...+a[i]\*(i-1)!+...+a[1]\*0!`** 

其中ai表示第i个元素在未出现的元素中排第几(从0开始排，不是从1开始排)

比如排列：1 3 2

a3 = 0（1排第一，从0开始排）, a2 = 1,a3 = 0; X = 1；故比1,3,2小的有一个。



在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。

- 首位是3，则小于3的数有两个，为1和2，a[5]=2，则首位小于3的所有排列组合为 a[0]*(5-1)!
- 第二位是4，则小于4的数有两个，为1和2，注意这里3并不能算，因为3已经在第一位，所以其实计算的是在第二位之后小于4的个数。因此a[4]=2
- 第三位是1，则在其之后小于1的数有0个，所以a[3]=0
- 第四位是5，则在其之后小于5的数有1个，为2，所以a[2]=1
- 最后一位就不用计算啦，因为在它之后已经没有数了，所以a[1]固定为0
- 根据公式： 

所以: X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0! 
= 2 * 24 + 2 * 6 + 1 
= 61 

所以比 34152 小的组合有61个，即34152是排第62。

```c++

int cantor(int s[]){
	int sum = 0;
	for(int i = 0;i < 9;++i){
		int num = 0;
		for(int j = i+1;j<9;++j){
			if(s[j] < s[i])num++;
		}
		sum += (num*fac[9-i-1]);
	}
 
	return sum + 1;
}
```







# **逆康托展开**

一开始已经提过了，康托展开是一个全排列到一个自然数的**双射**，因此是可逆的。即对于上述例子，在（1，2，3，4，5）给出61可以算出起排列组合为 34152。由上述的计算过程可以容易的逆推回来，具体过程如下：

- 用 61 / 4! = 2余13，说明a[5]=2,说明比首位小的数有2个，所以首位为3。
- 用 13 / 3! = 2余1，说明a[4]=2，说明在第二位之后小于第二位的数有2个，所以第二位为4。
- 用 1 / 2! = 0余1，说明a[3]=0，说明在第三位之后没有小于第三位的数，所以第三位为1。
- 用 1 / 1! = 1余0，说明a[2]=1，说明在第二位之后小于第四位的数有1个，所以第四位为5。

最后一位自然就是剩下的数2啦。
通过以上分析，所求排列组合为 34152。
具体代码实现如下：（假设排列数小于10个）

```c++
void decantor(int n, int k)//第k个排列
{
    vector<int> v;  // 存放当前可选数
    vector<int> a;  // 所求排列组合
    int f[11];
    f[1] = 1;
    for(int i = 1;i<11;++i)f[i] = f[i-1]*i;

    for(int i=1;i<=n;i++)
        v.push_back(i);

    
    --k;
    for(int i=n;i>=1;i--)
    {
        int r = k % f[i-1];
        int t = k/ f[i-1];
        k = r;
        sort(v.begin(),v.end());// 从小到大排序 
        a.push_back(v[t]);      // 从0开始排序,所以下标直接为t就好
        v.erase(v.begin()+t);   // 移除选做当前位的数
    }
}
```





# 应用

- 给定一个自然数组合成的一个全排列，求其中的一个排列在全排列中排第几。
- 反过来，在一个全排列中，第n个排列组合是多少。
- 一个数组映射到一个数，用于哈希，压缩空间。比如[八数码问题](https://blog.csdn.net/sgh666666/article/details/97617307)中，我们用康托展开求一个排列的rank用来记录这个排列的状态。